# -*- coding: utf-8 -*-
"""Signal&System_Project_Code.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E_XhBb2nq2aLFKWSj2-19w3Q5XZXiLqK
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider

def square_wave(t, T):
    """Square wave of period T."""
    t = np.mod(t, T)
    return np.where((t >= 0) & (t < T / 2), 1, -1)

def sine_wave(t, T):
    """Sine wave of fundamental frequency."""
    omega0 = 2 * np.pi / T
    return np.sin(omega0 * t)


# Exponential Fourier coefficients c_n
def exponential_coefficients(func_name, n_max, T):
    coeffs = np.zeros(2 * n_max + 1, dtype=complex)
    if func_name == "square":
        for n in range(-n_max, n_max + 1):
            if n == 0:
                coeffs[n + n_max] = 0
            elif n % 2 != 0:
                coeffs[n + n_max] = -2j / (n * np.pi)
    elif func_name == "sine":
        # Sine wave only has c1 and c-1 nonzero
        coeffs[n_max + 1] = -0.5j
        coeffs[n_max - 1] = 0.5j
        # All other coefficients remain zero
    return coeffs

# Trigonometric Fourier coefficients a_n, b_n
def trigonometric_coefficients(func_name, n_max):
    a0 = 0
    a = np.zeros(n_max + 1)
    b = np.zeros(n_max + 1)

    if func_name == "square":
        # Square wave expansion
        for n in range(1, n_max + 1):
            if n % 2 != 0:
                b[n] = 4 / (n * np.pi)
    elif func_name == "sine":
        b[1] = 1
    return a0, a, b
def synthesize_exponential(t, coeffs, T):
    series = np.zeros_like(t, dtype=complex)
    n_max = (len(coeffs) - 1) // 2
    omega0 = 2 * np.pi / T
    for i, c in enumerate(coeffs):
        n = i - n_max
        series += c * np.exp(1j * n * omega0 * t)
    return np.real(series)

def synthesize_trigonometric(t, a0, a, b, T):
    series = a0 / 2 * np.ones_like(t)
    omega0 = 2 * np.pi / T
    for n in range(1, len(a)):
        series += a[n] * np.cos(n * omega0 * t) + b[n] * np.sin(n * omega0 * t)
    return series


def visualize(func_name="square"):
    T = 2 * np.pi
    t = np.linspace(-3 * T, 3 * T, 1500)

    # Original signal
    if func_name == "square":
        orig = square_wave(t, T)
        title = "Square Wave"
    else:
        orig = sine_wave(t, T)
        title = "Sine Wave"

    # Setup plots
    fig, axes = plt.subplots(4, 1, figsize=(12, 18))
    plt.subplots_adjust(bottom=0.25, hspace=0.8)

    axes[0].plot(t, orig, 'k--', label="Original Signal", linewidth=2)
    axes[0].set_title(f"{title} Fourier Series Approximation", fontsize=16)
    axes[0].set_ylim(-1.5, 1.5)
    axes[0].grid(True, linestyle='--', alpha=0.5)

    # Initial Fourier approx
    N0 = 1
    coeffs_exp = exponential_coefficients(func_name, N0, T)
    approx_exp = synthesize_exponential(t, coeffs_exp, T)
    line_exp, = axes[0].plot(t, approx_exp, color='royalblue', label=f"Exponential (N={N0})", linewidth=2)

    a0, a, b = trigonometric_coefficients(func_name, N0)
    approx_tri = synthesize_trigonometric(t, a0, a, b, T)
    line_tri, = axes[0].plot(t, approx_tri, color='orange', label=f"Trigonometric (N={N0})", linewidth=2)

    axes[0].legend(fontsize=12, loc='upper right')

    # Exponential magnitude & phase
    n_vals = np.arange(-10, 11)
    coeffs_spectrum = exponential_coefficients(func_name, 10, T)

    axes[1].stem(n_vals, np.abs(coeffs_spectrum), basefmt=" ", linefmt='purple', markerfmt='D')
    axes[1].set_title("Exponential Fourier Magnitude |cₙ|", fontsize=14)
    axes[1].set_xlabel("n", fontsize=12)
    axes[1].grid(True, linestyle='--', alpha=0.5)

    phases = np.angle(coeffs_spectrum)
    phases[np.abs(coeffs_spectrum) < 1e-12] = 0
    axes[2].stem(n_vals, phases, basefmt=" ", linefmt='green', markerfmt='o')
    axes[2].set_title("Exponential Fourier Phase ∠cₙ", fontsize=14)
    axes[2].set_xlabel("n", fontsize=12)
    axes[2].set_yticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
    axes[2].set_yticklabels([r'$-\pi$', r'$-\pi/2$', '0', r'$\pi/2$', r'$\pi$'])
    axes[2].grid(True, linestyle='--', alpha=0.5)

    # Trigonometric coefficients
    bars_a = axes[3].bar(np.arange(len(a)), a, alpha=0.7, label="aₙ (cos)", color='deepskyblue')
    bars_b = axes[3].bar(np.arange(len(b)), b, alpha=0.7, label="bₙ (sin)", color='coral')
    axes[3].set_title("Trigonometric Fourier Coefficients", fontsize=14)
    axes[3].set_xlabel("n", fontsize=12)
    axes[3].legend(fontsize=12)
    axes[3].grid(True, linestyle='--', alpha=0.5)

    # Slider
    ax_slider = plt.axes([0.2, 0.08, 0.65, 0.03])
    slider = Slider(ax_slider, "N Terms", 1, 20, valinit=N0, valstep=1, color='royalblue')
    slider_label = fig.text(0.5, 0.04, f"N Terms: {N0}", ha='center', va='center', fontsize=12, color='royalblue')

    def update(val):
        N = int(slider.val)

        # Exponential reconstruction
        coeffs_exp = exponential_coefficients(func_name, N, T)
        approx_exp = synthesize_exponential(t, coeffs_exp, T)
        line_exp.set_ydata(approx_exp)

        # Trigonometric reconstruction
        a0, a, b = trigonometric_coefficients(func_name, N)
        approx_tri = synthesize_trigonometric(t, a0, a, b, T)
        line_tri.set_ydata(approx_tri)

        axes[0].legend(["Original Signal", f"Exponential (N={N})", f"Trigonometric (N={N})"], fontsize=12, loc='upper right')

        # Update trigonometric coefficient bars
        axes[3].cla()
        axes[3].bar(np.arange(len(a)), a, alpha=0.7, label="aₙ (cos)", color='deepskyblue')
        axes[3].bar(np.arange(len(b)), b, alpha=0.7, label="bₙ (sin)", color='coral')
        axes[3].set_title("Trigonometric Fourier Coefficients", fontsize=14)
        axes[3].set_xlabel("n", fontsize=12)
        axes[3].legend(fontsize=12)
        axes[3].grid(True, linestyle='--', alpha=0.5)

        slider_label.set_text(f"N Terms: {N}")
        fig.canvas.draw_idle()

    slider.on_changed(update)
    plt.show()

if __name__ == "__main__":
    print("Welcome to Fourier Series Visualization!")
    choice = input("Enter 'square' for square wave or 'sine' for sine wave: ").lower()
    if choice in ["square", "sine"]:
        visualize(choice)
    else:
        print("Invalid choice.")